var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This page contains the complete API documentation for DeviceSparseArrays.jl.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#DeviceSparseArrays.AbstractDeviceSparseArray","page":"API Reference","title":"DeviceSparseArrays.AbstractDeviceSparseArray","text":"AbstractDeviceSparseArray{Tv,Ti,N} <: AbstractSparseArray{Tv,Ti,N}\n\nSupertype for sparse arrays that can have their underlying storage on various devices (CPU, GPU, accelerators). This package keeps the hierarchy backend-agnostic; dispatch is expected to leverage the concrete types of internal buffers (e.g. Vector, CuArray, etc.) rather than an explicit backend flag.\n\n\n\n\n\n","category":"type"},{"location":"api/#DeviceSparseArrays.DeviceSparseVector","page":"API Reference","title":"DeviceSparseArrays.DeviceSparseVector","text":"DeviceSparseVector{Tv,Ti,IndT<:AbstractVector{Ti},ValT<:AbstractVector{Tv}} <: AbstractDeviceSparseVector{Tv,Ti}\n\nSparse vector with generic index and value storage containers which may reside on different devices. The logical length is stored along with index/value buffers.\n\nFields:   n::Ti          - logical length of the vector   nzind::IndT    - indices of stored (typically nonzero) entries (1-based)   nzval::ValT    - stored values\n\nConstructors validate that the index and value vectors have matching length.\n\n\n\n\n\n","category":"type"},{"location":"api/#DeviceSparseArrays.DeviceSparseMatrixCSC","page":"API Reference","title":"DeviceSparseArrays.DeviceSparseMatrixCSC","text":"DeviceSparseMatrixCSC{Tv,Ti,ColPtrT<RowValT,NzValT} <: AbstractDeviceSparseMatrix{Tv,Ti}\n\nCompressed Sparse Column (CSC) matrix with generic storage vectors for column pointer, row indices, and nonzero values. Buffer types (e.g. Vector, GPU array types) enable dispatch on device characteristics.\n\nFields:   m::Int               - number of rows   n::Int               - number of columns   colptr::ColPtrT      - column pointer array (length n+1)   rowval::RowValT      - row indices of stored entries   nzval::NzValT        - stored values\n\n\n\n\n\n","category":"type"},{"location":"api/#DeviceSparseArrays.DeviceSparseMatrixCSR","page":"API Reference","title":"DeviceSparseArrays.DeviceSparseMatrixCSR","text":"DeviceSparseMatrixCSR{Tv,Ti,RowPtrT<:ColValT,NzValT} <: AbstractDeviceSparseMatrix{Tv,Ti}\n\nCompressed Sparse Row (CSR) matrix with generic storage vectors for row pointer, column indices, and nonzero values. Buffer types (e.g. Vector, GPU array types) enable dispatch on device characteristics.\n\nFields:   m::Int               - number of rows   n::Int               - number of columns   rowptr::RowPtrT      - row pointer array (length m+1)   colval::ColValT      - column indices of stored entries   nzval::NzValT        - stored values\n\n\n\n\n\n","category":"type"},{"location":"api/#Functions","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"#DeviceSparseArrays","page":"Home","title":"DeviceSparseArrays","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DeviceSparseArrays.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DeviceSparseArrays provides backend-agnostic sparse array container types whose internal storage vectors may live on different devices (CPU / accelerators). The initial implementation supplies:","category":"page"},{"location":"","page":"Home","title":"Home","text":"DeviceSparseVector – sparse vector with generic index & value buffers.\nDeviceSparseMatrixCSC – Compressed Sparse Column matrix with parametric column pointer, row index, and nonzero value buffers.\nDeviceSparseMatrixCSR – Compressed Sparse Row matrix with parametric row pointer, column index, and nonzero value buffers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"These types mirror the Base SparseVector / SparseMatrixCSC interfaces for introspection (size, length, nonzeros, etc.) and can roundtrip convert to and from the Base representations.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using DeviceSparseArrays, SparseArrays\n\n# Create a sparse vector\nV = sparsevec([2,5], [1.0, 3.5], 6)\ndV = DeviceSparseVector(V)  # construct backend-agnostic version on the CPU\n\n@show size(dV)\n@show SparseVector(dV) == V\n\n# Create a sparse matrix\nA = sparse([1,2,1],[1,1,2],[2.0,3.0,4.0], 2, 2)\ndA = DeviceSparseMatrixCSC(A)\n\n@show size(dA)\n@show SparseMatrixCSC(dA) == A","category":"page"},{"location":"#Matrix-Vector-Multiplication","page":"Home","title":"Matrix-Vector Multiplication","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Create a sparse matrix\nA_sparse = sparse([1,2,1,3],[1,1,2,3],[2.0,3.0,4.0,5.0], 3, 3)\n@show A_sparse\n\n# Convert to DeviceSparseMatrixCSC\nA_device = DeviceSparseMatrixCSC(A_sparse)\n\n# Create a vector\nb = [1.0, 2.0, 3.0]\n\n# Matrix-vector multiplication\nc = A_device * b\n@show c\n\n# Verify result matches standard sparse matrix\n@show A_sparse * b == c","category":"page"},{"location":"#Backend-Adaptation-with-JLArrays","page":"Home","title":"Backend Adaptation with JLArrays","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JLArrays.jl provides a CPU fallback backend for testing and CI purposes. Here we use it to demonstrate backend adaptation with Adapt.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using JLArrays\nusing Adapt: adapt\n\n# Create a sparse matrix\nA_sparse = sprand(Float64, 5, 4, 0.6)\n\n# Convert to DeviceSparseMatrixCSC\nA_device = DeviceSparseMatrixCSC(A_sparse)\n\n# Adapt to JLArray backend (CPU fallback for CI)\nA_jl = adapt(JLArray, A_device)\n\n# Create vector on same backend\nb = rand(Float64, 4)\nb_jl = JLArray(b)\n\n# Matrix-vector multiplication on JLArray backend\nc_jl = A_jl * b_jl\n\n# Results should match\n@show collect(c_jl) ≈ A_sparse * b","category":"page"},{"location":"#CSR-Matrix-Format","page":"Home","title":"CSR Matrix Format","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DeviceSparseArrays.jl also supports the Compressed Sparse Row (CSR) format via the DeviceSparseMatrixCSR type. It can be used similarly to the CSC format. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Create a sparse matrix\nA_sparse = sparse([1,2,1,3],[1,1,2,3],[2.0,3.0,4.0,5.0], 3, 3)\n\n# Convert to CSR format\nA_csr = DeviceSparseMatrixCSR(A_sparse)\n@show size(A_csr)\n\n# Convert back to standard sparse matrix\n@show SparseMatrixCSC(A_csr) == A_sparse\n\n# Matrix-vector multiplication with CSR\nb = [1.0, 2.0, 3.0]\nc = A_csr * b\n@show c","category":"page"},{"location":"#Future-Work","page":"Home","title":"Future Work","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Planned extensions include COO formats, sparse-dense and sparse-sparse linear algebra kernels leveraging KernelAbstractions.jl / AcceleratedKernels.jl, and device-specific adaptations via dispatch on the internal buffer types.","category":"page"},{"location":"#See-Also","page":"Home","title":"See Also","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"API Reference for complete function documentation","category":"page"}]
}
