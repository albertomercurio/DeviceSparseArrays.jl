var documenterSearchIndex = {"docs":
[{"location":"#DeviceSparseArrays","page":"Home","title":"DeviceSparseArrays","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DeviceSparseArrays.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DeviceSparseArrays provides backend-agnostic sparse array container types whose internal storage vectors may live on different devices (CPU / accelerators). The initial implementation supplies:","category":"page"},{"location":"","page":"Home","title":"Home","text":"DeviceSparseVector – sparse vector with generic index & value buffers.\nDeviceSparseMatrixCSC – Compressed Sparse Column matrix with parametric","category":"page"},{"location":"","page":"Home","title":"Home","text":"column pointer, row index, and nonzero value buffers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"These types mirror the Base SparseVector / SparseMatrixCSC interfaces for introspection (size, length, nonzeros, etc.) and can roundtrip convert to and from the Base representations.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using DeviceSparseArrays, SparseArrays\n\njulia> V = sparsevec([2,5], [1.0, 3.5], 6);\n\njulia> dV = DeviceSparseVector(V);  # construct backend-agnostic version\n\njulia> size(dV)\n(6,)\n\njulia> SparseVector(dV) == V\ntrue\n\njulia> A = sparse([1,2,1],[1,1,2],[2.0,3.0,4.0], 2, 2);\n\njulia> dA = DeviceSparseMatrixCSC(A);\n\njulia> size(dA)\n(2, 2)\n\njulia> SparseMatrixCSC(dA) == A\ntrue","category":"page"},{"location":"#Future-Work","page":"Home","title":"Future Work","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Planned extensions include CSR / COO formats, sparse-dense and sparse-sparse linear algebra kernels leveraging KernelAbstractions / AcceleratedKernels, and device-specific adaptations via dispatch on the internal buffer types.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#DeviceSparseArrays.AbstractDeviceSparseArray","page":"Home","title":"DeviceSparseArrays.AbstractDeviceSparseArray","text":"AbstractDeviceSparseArray{Tv,Ti,N} <: AbstractSparseArray{Tv,Ti,N}\n\nSupertype for sparse arrays that can have their underlying storage on various devices (CPU, GPU, accelerators). This package keeps the hierarchy backend-agnostic; dispatch is expected to leverage the concrete types of internal buffers (e.g. Vector, CuArray, etc.) rather than an explicit backend flag.\n\n\n\n\n\n","category":"type"},{"location":"#DeviceSparseArrays.DeviceSparseMatrixCSC","page":"Home","title":"DeviceSparseArrays.DeviceSparseMatrixCSC","text":"DeviceSparseMatrixCSC{Tv,Ti,ColPtrT<RowValT,NzValT} <: AbstractDeviceSparseMatrixCSC{Tv,Ti}\n\nCompressed Sparse Column (CSC) matrix with generic storage vectors for column pointer, row indices, and nonzero values. Buffer types (e.g. Vector, GPU array types) enable dispatch on device characteristics.\n\nFields:   m::Int               - number of rows   n::Int               - number of columns   colptr::ColPtrT      - column pointer array (length n+1)   rowval::RowValT      - row indices of stored entries   nzval::NzValT        - stored values\n\n\n\n\n\n","category":"type"},{"location":"#DeviceSparseArrays.DeviceSparseVector","page":"Home","title":"DeviceSparseArrays.DeviceSparseVector","text":"DeviceSparseVector{Tv,Ti,IndT<:AbstractVector{Ti},ValT<:AbstractVector{Tv}} <: AbstractDeviceSparseVector{Tv,Ti}\n\nSparse vector with generic index and value storage containers which may reside on different devices. The logical length is stored along with index/value buffers.\n\nFields:   n::Ti          - logical length of the vector   nzind::IndT    - indices of stored (typically nonzero) entries (1-based)   nzval::ValT    - stored values\n\nConstructors validate that the index and value vectors have matching length.\n\n\n\n\n\n","category":"type"}]
}
